---
title: "Untitled"
output: html_document
date: "2024-12-08"
---

---
title: "Projekt Analiza Danych"
date: "`r Sys.Date()`"
output:
  rmdformats::downcute:
    self_contained: true
    default_style: "light"
    downcute_theme: "default"
---

\# Projekt_Analiza_Danych

GitGirls

W składzie: 1. Natalia Adamczyk 2. Paulina Lackowska 3. Wiktoria Gliniecka

Baza danych: Agencja nieruchomości - raport na temat agencji nieruchomości, dowiedzieć się od czego zależy CENA nieruchomości, czyli domy, mieszkania.

Plik: agencja_nieruchomosci

```{r setup, include=FALSE}
## Global optionsuuuuuu
knitr::opts_chunk$set(cache = TRUE)
```

```{r}
library(dplyr)
library(naniar)
library(ggplot2)
library(VIM)
library(editrules)
library(validate)
library(editrules)
library(xts)

```

```{r}
#Read data from .csv
data <- read.csv("agencja_nieruchomosci.csv")
```

Podgląd danych

```{r}
#Data preview
head(data)
```

Struktura danych

```{r}
str(data)
```

# Data Wrangling

## Eksploracja braków danych

Całkowita liczbę NA dla całej ramki danych lub dla określonej zmiennej (kolumny)

```{r}
n_miss(data)
```

Całkowita liczbę NA dla zmiennych (kolumn)

```{r}
n_miss(data$price)
n_miss(data$area)
n_miss(data$bedrooms)
n_miss(data$bathrooms)
n_miss(data$stories)
n_miss(data$mainroad)
n_miss(data$guestroom)
n_miss(data$basement)
n_miss(data$hotwaterheating)
n_miss(data$airconditioning)
n_miss(data$parking)
n_miss(data$prefarea)
n_miss(data$furnishingstatus)
```

liczba wartości innych niż NA w ramce danych lub zmiennej

```{r}
n_complete(data)
```

Proporcja wartości będących NA dla całej ramki danych

```{r}
prop_miss(data)
```

Proporcja wartości będących NA dla poszczególnych kolumn

```{r}
prop_miss(data$price)
prop_miss(data$area)
prop_miss(data$bedrooms)
prop_miss(data$bathrooms)
prop_miss(data$stories)
prop_miss(data$mainroad)
prop_miss(data$guestroom)
prop_miss(data$basement)
prop_miss(data$hotwaterheating)
prop_miss(data$airconditioning)
prop_miss(data$parking)
prop_miss(data$prefarea)
prop_miss(data$furnishingstatus)
```

tabelę podsumowującą zawierającą liczbę brakujących NA

```{r}
miss_var_summary(data) 
```

Wizualizacja brakujących wartości

```{r}
vis_miss(data)
```


## Porządkowanie struktury danych 

### Zmiana wartości (yes/no) na wartości (TRUE/FALSE) 

```{r}
data$mainroad <- ifelse(data$mainroad == "yes", TRUE, 
                                ifelse(data$mainroad == "no", FALSE, NA))
                                
data$guestroom <- ifelse(data$guestroom == "yes", TRUE, 
                                ifelse(data$guestroom == "no", FALSE, NA))

data$basement <- ifelse(data$basement == "yes", TRUE, 
                                ifelse(data$basement == "no", FALSE, NA))

data$hotwaterheating <- ifelse(data$hotwaterheating == "yes", TRUE, 
                                ifelse(data$hotwaterheating == "no", FALSE, NA))

data$airconditioning <- ifelse(data$airconditioning == "yes", TRUE, 
                                ifelse(data$airconditioning == "no", FALSE, NA))
                                
data$prefarea <- ifelse(data$prefarea == "yes", TRUE, 
                                ifelse(data$prefarea == "no", FALSE, NA))

```

## Definiowanie reguł w celu zwiększenia spójności danych

```{r}
RULE <- editset(c("price > 0","area > 0", "bedrooms >= 1","bathrooms >= 1", "stories >= 1", "mainroad %in% c(TRUE,FALSE)","guestroom %in% c(TRUE,FALSE)", "basement %in% c(TRUE,FALSE)", "hotwaterheating %in% c(TRUE,FALSE)", "airconditioning %in% c(TRUE,FALSE)", "prefarea %in% c(TRUE,FALSE)", "parking >= 0", "furnishingstatus %in% c('furnished','semi-furnished','unfurnished')"))
RULE
```

### Podsumowanie rekordów niespełniających ustalonej wyżej reguły

```{r}
summary(violatedEdits(RULE, data))
violations_summary <- summary(violatedEdits(RULE, data))
str(violations_summary)


plot(violated)

```

Z podsumowania danych łamiących zapisaną wyżej regułę wynika, że większość wierszy (66.6%) w danych spełnia wszystkie reguły walidacyjne (errors = 0). 28.4% wierszy narusza jedną regułę (errors = 1). 4.8% wierszy narusza dwie reguły (errors = 2). 0.2% wierszy narusza trzy reguły (errors = 3).To jaka część obserwacji nie spełani reguł możemy zobaczyć na wykresie.

Dla spójności i poprawności danych stodujemy reguły walidacyjne. Wykorzystujemy zdefiniowane wcześniej reguły. Błędne wartości w danych zastąpujemy NA, co umożliwia ich łatwą identyfikację i w puźniejszych krokach ułatwi wykosztanie ich w analizie. Wykorzystujemy do tego celu bibliotekę validate, aby wszytskie obserwacje łamiące wspomniane regułu zastępujemy wartością NA.Oznacza to, że będzie możliwe implementacja w to miejsce wartości spełniające wymogi danych.

```{r}
RULE <- validator(
  price > 0,
  area > 0,
  bedrooms >= 1,
  bathrooms >= 1,
  stories >= 1,
  mainroad %in% c('TRUE', 'FALSE'),
  guestroom %in% c('TRUE', 'FALSE'),
  basement %in% c('TRUE', 'FALSE'),
  hotwaterheating %in% c('TRUE', 'FALSE'),
  airconditioning %in% c('TRUE', 'FALSE'),
  prefarea %in% c('TRUE', 'FALSE'),
  parking >= 0,
  furnishingstatus %in% c('furnished', 'semi-furnished', 'unfurnished')
)

correct_with_rules <- function(data, rules) {
  violations <- confront(data, rules)
  for (col in names(data)) {
    if (col %in% names(rules)) {
      invalid_rows <- values(violations)[, col] == FALSE
      data[[col]][invalid_rows] <- NA
    }
  }
  return(data)
}
```

## Wartości odstające 

### Analiza wartości odstających dla zmiennej 'price'

Identyfikujemy wartości odstające w zmiennej `price` Następnie znajdujemy indeksy wierszy zawierających te wartości odstające za pomocą funkcji `which`. Używamy wykresu pudełkowegp do wizualizacji zmiennej `price`, gdzie outliery są automatycznie zaznaczane na wykresie. W kolejnych krokach modyfikujemy wartości w drugiej kolumnie dla wierszy z wartościami odstającymi w `price`, dzieląc je przez 10 w celu ich zmniejszenia. Ten proces pozwala nam spojrzeć na przeciętne wartości dla danych o sprzedaży mieszkań. Jeśli chodzi o cenę jest ona zmienną mocno subiektywną. Niekoniecznie wynika z faktycznej wartości produktu ale np. z bardzo konkretnej lokalizacji. Ponieważ w naszych danych nie mamy informacji o np. wspomnianej konkretnej lokalizacji nie możemy wziąć jej pod uwagę przy dalaszej interpretacji ceny. Dane bez wprowqadzonych modyfikacji zostawiamy jako 'data_with_outliars'dla celów porównawczych.

```{r}
outliers <- boxplot.stats(data$price)$out
outliers_idx <- which(data$price %in% outliers)
data[outliers_idx,]

boxplot(data$price, 
        main = "Wartości odstające dla zmiennej 'price'",
        ylab = "Wartości price",
        col = "lightblue",
        outline = TRUE)

data[outliers_idx, 2] <- data[outliers_idx, 2] / 10

data_with_outliars <- read.csv("agencja_nieruchomosci.csv")
```

### Analiza wartości odstających dla zmiennej 'area'

Drugą zmienną w której mogą wystapić wartości odstające jest zmienna 'area'. Dlatego przechodzimy do identyfikacji wartości odstających w zmiennej `area` do ich lepszego zobrazowania wykorzystamy wykres pudełkowy. Widzimy, że są to wartości ekstremalnie wysokie. Na razie nie będziemy modyfikować tych wartości. Z perspektywy biznesowej ważne jest aby zbadać jak duża powierzchnia wpływa na cenę. Czy w przypadku odstających pod katem wielkości są one również zdecydowanie droższe.

```{r}

outliers <- boxplot.stats(data$area)$out
outliers_idx <- which(data$area %in% outliers)
data[outliers_idx,]

boxplot(data$area, 
        main = "Wartości odstające dla zmiennej 'area'",
        ylab = "Wartości area",
        col = "lightblue",
        outline = TRUE)

```

# Eksploracja danych

## Sortowanie danych rosnąco według zmiennej 'price'.

Ponieważ Dla naszej analizy kluczową zmienną będzie cena a pytania jake sobie postawimy będą głównie związane z tym jakie czynniki na nią wpływają. ustawienie danych roznąco pod kątem ceny ułatwi prace i podglądanie struktury danych. Łatwiej w ten sposób zauważyć jakie są

```{r}
data %>% arrange('price')
```

## Analiza struktury danych pod kątem zmiennych

```{r}

logical_columns <- c("mainroad", "guestroom", "basement", "hotwaterheating", "airconditioning", "prefarea")

for (col in logical_columns) {
  total <- sum(!is.na(data[[col]]))
  true_percent <- round(sum(data[[col]] == TRUE, na.rm = TRUE) / total * 100, 2)
  false_percent <- round(sum(data[[col]] == FALSE, na.rm = TRUE) / total * 100, 2)
  cat(sprintf("Kolumna: %s, TRUE: %.2f%%, FALSE: %.2f%%\n", col, true_percent, false_percent))
}
```

Kolumna: mainroad, TRUE: 86.46%, FALSE: 13.54%
Kolumna: guestroom, TRUE: 17.80%, FALSE: 82.20%
Kolumna: basement, TRUE: 35.05%, FALSE: 64.95%
Kolumna: hotwaterheating, TRUE: 4.59%, FALSE: 95.41%
Kolumna: airconditioning, TRUE: 31.56%, FALSE: 68.44%
Kolumna: prefarea, TRUE: 24.65%, FALSE: 75.35%

Dodatkowo aby lepiej zobarzować dane pokazane w podsumowaniu tworzymy wykresy słupkowe dla podanych zmiennych

```{r}
for (col in logical_columns) {
  true_percent <- mean(data[[col]] == TRUE, na.rm = TRUE) * 100
  false_percent <- mean(data[[col]] == FALSE, na.rm = TRUE) * 100
  
  barplot(
    c("TRUE" = true_percent, "FALSE" = false_percent),
    main = paste("Procent TRUE/FALSE dla", col),
    ylab = "Procent",
    col = c("lightblue", "lightcoral")
  )
}
```

### Analiza struktury danych dla zmiennej 'furnishingstatus'

```{r}
furnishing_counts <- table(data$furnishingstatus)
furnishing_percentages <- round(prop.table(furnishing_counts) * 100, 2)


print(furnishing_percentages)


barplot(
  furnishing_percentages,
  main = "Procentowy rozkład furnishingstatus",
  ylab = "Procent",
  col = c("lightblue", "lightgreen", "lightcoral"),
  names.arg = names(furnishing_percentages)
)
```

## Imputacja braków danych metodą sequential hotdeck

Zdecydowałyśmy się na metodę sequential hot-deck do imputacji brakujących danych.Metoda Sequential hot-deck wykorzystuje rzeczywiste wartości z naszego zbioru danych, co sprawia, że prawdopodobieństwo wprowadzenia sztucznych wartości jest małe. Dodatkowo załeży nam na zachowaniu naturalnego rozkładu danych. Metoda ta jest elastyczna i działa zarówno dla danych liczbowych, jak i kategorycznych, nie wymagając założeń o rozkładzie zmiennych. Dodatkowo, metoda ta jest odporna na outliery co było dla nas ważne po wcześniejszym zbadaniu ich występowania dla zmiennych price i area. na koniec prównamy brakujące dane przed i po imputacji aby upewnić się, że proces przebiegł pomyślnie.

```{r}

data_not_cleaned <- hotdeck(data)


cat("Liczba brakujących wartości po imputacji:", sum(is.na(data_not_cleaned)), "\n")


remove_imp_columns <- function(df) {
 
  if (!is.data.frame(df)) {
    stop("Podany obiekt nie jest ramką danych")
  }
  
 
  imp_cols <- grep("_imp$", colnames(df), value = TRUE)
  
 
  if (length(imp_cols) == 0) {
    message("Nie znaleziono kolumn z '_imp' w nazwie.")
    return(df)
  }
  

  df_cleaned <- df[, !colnames(df) %in% imp_cols]
  
  message("Usunięto następujące kolumny: ", paste(imp_cols, collapse = ", "))
  
  return(df_cleaned)
}


data_imputed <- remove_imp_columns(data_not_cleaned)


cat("Struktura danych po usunięciu kolumn '_imp':")
str(data_imputed)


head(data_imputed)
```
#Normalizacja zmiennych numerycznych 

Kolejnym etapem jest normalizacja zmiennych numerycznych, takich jak cena, powierzchnia, liczba sypialni, czy liczba miejsc parkingowych, co pozwala na przekształcenie danych do wspólnej skali bez utraty relatywnej informacji. Do tego celu wykorzystano metodę min-max scaling, która przekształca wartości w przedziale od 0 do 1, co ułatwia dalsze analizy statystyczne oraz modelowanie. Proces normalizacji zapewnia większą spójność danych i eliminuje wpływ różnych skal poszczególnych zmiennych na wyniki analizy.Dzięki zastosowanym technikom przetwarzania danych uzyskane wyniki pozwolą na dokładniejszą interpretację wpływu poszczególnych cech nieruchomości na ich wartość rynkową oraz na lepsze przygotowanie danych do wykorzystania w modelach predykcyjnych.

```{r}
minmax <- function(data, columns_to_normalize) {
 
  missing_cols <- setdiff(columns_to_normalize, colnames(data))
  if (length(missing_cols) > 0) {
    stop(paste("Nie znaleziono kolumn:", paste(missing_cols, collapse = ", ")))
  }
  
  data_normalized <- data %>%
    mutate(across(all_of(columns_to_normalize), 
                  ~ (.-min(., na.rm = TRUE)) / (max(., na.rm = TRUE) - min(., na.rm = TRUE)),
                  .names = "norm_{.col}"))
  
  return(data_normalized)
}

columns_to_normalize <- c("price", "area", "bedrooms", "bathrooms", "stories", "parking")

str(data_imputed)

data_imputed <- minmax(data, columns_to_normalize)

head(data_imputed)
```
Wizualizacja danych


```{r}
gg_miss_upset(data, 
              nsets = 3)

ggplot(data = data, aes(x = price, y = furnishingstatus)) +
  geom_point(size = 2, color = "cyan4") +
  theme_minimal()
```

Załaduj ggplot2
Tworzenie wykresu punktowego

```{r} 



ggplot(data = data, aes(x = area, y = price)) +
  geom_point() +
  labs(
    title = "Cena nieruchomości wg powierzchni",
    x = "Powierzchnia",
    y = "Cena"
  ) +
  theme_minimal()

library(ggplot2)
```
```
Wykres punktowy ceny w zależności od powierzchni

```{r}
ggplot(data = data, aes(x = area, y = price)) +
  geom_point(aes(color = price), size = 3, alpha = 0.7) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(
    title = "Cena nieruchomości w zależności od powierzchni",
    x = "Powierzchnia (m²)",
    y = "Cena (zł)",
    color = "Cena"
  ) +
  theme_minimal()
```

Wykres słupkowy pięter w zależności od umeblowania

```{r}
ggplot(data = data, aes(x = factor(stories), fill = furnishingstatus)) +
  geom_bar(position = "dodge") +
  labs(
    title = "Liczba pięter w zależności od statusu umeblowania",
    x = "Liczba pięter",
    y = "Liczba nieruchomości",
    fill = "Status umeblowania"
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")
```

Wykres boxplot ceny względem klimatyzacji

```{r}
ggplot(data = data, aes(x = factor(airconditioning), y = price, fill = factor(airconditioning))) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("skyblue", "orange")) +
  labs(
    title = "Cena nieruchomości w zależności od klimatyzacji",
    x = "Klimatyzacja (0 = brak, 1 = obecna)",
    y = "Cena (zł)",
    fill = "Klimatyzacja"
  ) +
  theme_minimal()
```

Histogram cen z uwzględnieniem głównej drogi

```{r}
ggplot(data = data, aes(x = price, fill = factor(mainroad))) +
  geom_histogram(position = "dodge", bins = 30, alpha = 0.7) +
  scale_fill_manual(values = c("darkgreen", "yellow")) +
  labs(
    title = "Rozkład cen nieruchomości w zależności od obecności przy głównej drodze",
    x = "Cena (zł)",
    y = "Liczba nieruchomości",
    fill = "Główna droga (0 = brak, 1 = obecność)"
  ) +
  theme_minimal()
```

Zmiana zmiennych na kategorie, jeśli nie są już ustawione

```{r}
data <- data %>%
  mutate(
    mainroad = as.factor(mainroad),
    prefarea = as.factor(prefarea),
    airconditioning = as.factor(airconditioning),
    guestroom = as.factor(guestroom),
    basement = as.factor(basement),
    hotwaterheating = as.factor(hotwaterheating),
    furnishingstatus = as.factor(furnishingstatus)
  )
```

```{r}
ggplot(data = data, aes(x = mainroad, y = price, fill = mainroad)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("darkgreen", "yellow")) +
  labs(
    title = "Cena nieruchomości w zależności od obecności głównej drogi",
    x = "Główna droga (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Główna droga"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = prefarea, y = price, fill = prefarea)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("skyblue", "orange")) +
  labs(
    title = "Cena nieruchomości w zależności od preferowanej lokalizacji",
    x = "Preferowana lokalizacja (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Preferowana lokalizacja"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = airconditioning, y = price, fill = airconditioning)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("blue", "red")) +
  labs(
    title = "Cena nieruchomości w zależności od klimatyzacji",
    x = "Klimatyzacja (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Klimatyzacja"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = guestroom, y = price, fill = guestroom)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("purple", "green")) +
  labs(
    title = "Cena nieruchomości w zależności od pokoju gościnnego",
    x = "Pokój gościnny (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Pokój gościnny"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = basement, y = price, fill = basement)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("grey", "brown")) +
  labs(
    title = "Cena nieruchomości w zależności od piwnicy",
    x = "Piwnica (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Piwnica"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = hotwaterheating, y = price, fill = hotwaterheating)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("cyan", "pink")) +
  labs(
    title = "Cena nieruchomości w zależności od ogrzewania ciepłą wodą",
    x = "Ogrzewanie ciepłą wodą (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Ogrzewanie"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = furnishingstatus, y = price, fill = furnishingstatus)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Cena nieruchomości w zależności od statusu umeblowania",
    x = "Status umeblowania",
    y = "Cena (zł)",
    fill = "Umeblowanie"
  ) +
  theme_minimal()
