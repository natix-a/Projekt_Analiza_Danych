---
title: "Untitled"
output: html_document
date: "2024-12-08"
---

---
title: "Projekt Analiza Danych"
date: "`r Sys.Date()`"
output:
  rmdformats::downcute:
    self_contained: true
    default_style: "light"
    downcute_theme: "default"
---

\# Projekt_Analiza_Danych

GitGirls

W składzie: 1. Natalia Adamczyk 2. Paulina Lackowska 3. Wiktoria Gliniecka

Baza danych: Agencja nieruchomości - raport na temat agencji nieruchomości, dowiedzieć się od czego zależy CENA nieruchomości, czyli domy, mieszkania.

Plik: agencja_nieruchomosci

```{r setup, include=FALSE}
## Global optionsuuuuuu
knitr::opts_chunk$set(cache = TRUE)
```

```{r}
library(dplyr)
library(naniar)
library(ggplot2)
library(VIM)
library(editrules)
library(validate)
library(editrules)
library(xts)

```

```{r}
#Read data from .csv
data <- read.csv("agencja_nieruchomosci.csv")
```

Podgląd danych

```{r}
#Data preview
head(data)
```

Struktura danych

```{r}
str(data)
```

# Data Wrangling

## Eksploracja braków danych

Całkowita liczbę NA dla całej ramki danych lub dla określonej zmiennej (kolumny)

```{r}
n_miss(data)
```

Całkowita liczbę NA dla zmiennych (kolumn)

```{r}
n_miss(data$price)
n_miss(data$area)
n_miss(data$bedrooms)
n_miss(data$bathrooms)
n_miss(data$stories)
n_miss(data$mainroad)
n_miss(data$guestroom)
n_miss(data$basement)
n_miss(data$hotwaterheating)
n_miss(data$airconditioning)
n_miss(data$parking)
n_miss(data$prefarea)
n_miss(data$furnishingstatus)
```

liczba wartości innych niż NA w ramce danych lub zmiennej

```{r}
n_complete(data)
```

Proporcja wartości będących NA dla całej ramki danych

```{r}
prop_miss(data)
```

Proporcja wartości będących NA dla poszczególnych kolumn

```{r}
prop_miss(data$price)
prop_miss(data$area)
prop_miss(data$bedrooms)
prop_miss(data$bathrooms)
prop_miss(data$stories)
prop_miss(data$mainroad)
prop_miss(data$guestroom)
prop_miss(data$basement)
prop_miss(data$hotwaterheating)
prop_miss(data$airconditioning)
prop_miss(data$parking)
prop_miss(data$prefarea)
prop_miss(data$furnishingstatus)
```

tabelę podsumowującą zawierającą liczbę brakujących NA

```{r}
miss_var_summary(data) 
```

Wizualizacja brakujących wartości

```{r}
vis_miss(data)
```


## Porządkowanie struktury danych 

### Zmiana wartości (yes/no) na wartości (TRUE/FALSE) 

```{r}
data$mainroad <- ifelse(data$mainroad == "yes", TRUE, 
                                ifelse(data$mainroad == "no", FALSE, NA))
                                
data$guestroom <- ifelse(data$guestroom == "yes", TRUE, 
                                ifelse(data$guestroom == "no", FALSE, NA))

data$basement <- ifelse(data$basement == "yes", TRUE, 
                                ifelse(data$basement == "no", FALSE, NA))

data$hotwaterheating <- ifelse(data$hotwaterheating == "yes", TRUE, 
                                ifelse(data$hotwaterheating == "no", FALSE, NA))

data$airconditioning <- ifelse(data$airconditioning == "yes", TRUE, 
                                ifelse(data$airconditioning == "no", FALSE, NA))
                                
data$prefarea <- ifelse(data$prefarea == "yes", TRUE, 
                                ifelse(data$prefarea == "no", FALSE, NA))

```

## Definiowanie reguł w celu zwiększenia spójności danych

```{r}
RULE <- editset(c("price > 0","area > 0", "bedrooms >= 1","bathrooms >= 1", "stories >= 1", "mainroad %in% c(TRUE,FALSE)","guestroom %in% c(TRUE,FALSE)", "basement %in% c(TRUE,FALSE)", "hotwaterheating %in% c(TRUE,FALSE)", "airconditioning %in% c(TRUE,FALSE)", "prefarea %in% c(TRUE,FALSE)", "parking >= 0", "furnishingstatus %in% c('furnished','semi-furnished','unfurnished')"))
RULE
```

### Podsumowanie rekordów niespełniających ustalonej wyżej reguły

```{r}
summary(violatedEdits(RULE, data))
violations_summary <- summary(violatedEdits(RULE, data))
str(violations_summary)


plot(violated)

```

Z podsumowania danych łamiących zapisaną wyżej regułę wynika, że większość wierszy (66.6%) w danych spełnia wszystkie reguły walidacyjne (errors = 0). 28.4% wierszy narusza jedną regułę (errors = 1). 4.8% wierszy narusza dwie reguły (errors = 2). 0.2% wierszy narusza trzy reguły (errors = 3).To jaka część obserwacji nie spełani reguł możemy zobaczyć na wykresie.

Dla spójności i poprawności danych stodujemy reguły walidacyjne. Wykorzystujemy zdefiniowane wcześniej reguły. Błędne wartości w danych zastąpujemy NA, co umożliwia ich łatwą identyfikację i w puźniejszych krokach ułatwi wykosztanie ich w analizie. Wykorzystujemy do tego celu bibliotekę validate, aby wszytskie obserwacje łamiące wspomniane regułu zastępujemy wartością NA.Oznacza to, że będzie możliwe implementacja w to miejsce wartości spełniające wymogi danych.

```{r}
RULE <- validator(
  price > 0,
  area > 0,
  bedrooms >= 1,
  bathrooms >= 1,
  stories >= 1,
  mainroad %in% c('TRUE', 'FALSE'),
  guestroom %in% c('TRUE', 'FALSE'),
  basement %in% c('TRUE', 'FALSE'),
  hotwaterheating %in% c('TRUE', 'FALSE'),
  airconditioning %in% c('TRUE', 'FALSE'),
  prefarea %in% c('TRUE', 'FALSE'),
  parking >= 0,
  furnishingstatus %in% c('furnished', 'semi-furnished', 'unfurnished')
)

correct_with_rules <- function(data, rules) {
  violations <- confront(data, rules)
  for (col in names(data)) {
    if (col %in% names(rules)) {
      invalid_rows <- values(violations)[, col] == FALSE
      data[[col]][invalid_rows] <- NA
    }
  }
  return(data)
}
```

## Wartości odstające 

### Analiza wartości odstających dla zmiennej 'price'

Identyfikujemy wartości odstające w zmiennej `price` Następnie znajdujemy indeksy wierszy zawierających te wartości odstające za pomocą funkcji `which`. Używamy wykresu pudełkowegp do wizualizacji zmiennej `price`, gdzie outliery są automatycznie zaznaczane na wykresie. W kolejnych krokach modyfikujemy wartości w drugiej kolumnie dla wierszy z wartościami odstającymi w `price`, dzieląc je przez 10 w celu ich zmniejszenia. Ten proces pozwala nam spojrzeć na przeciętne wartości dla danych o sprzedaży mieszkań. Jeśli chodzi o cenę jest ona zmienną mocno subiektywną. Niekoniecznie wynika z faktycznej wartości produktu ale np. z bardzo konkretnej lokalizacji. Ponieważ w naszych danych nie mamy informacji o np. wspomnianej konkretnej lokalizacji nie możemy wziąć jej pod uwagę przy dalaszej interpretacji ceny. Dane bez wprowqadzonych modyfikacji zostawiamy jako 'data_with_outliars'dla celów porównawczych.

```{r}
outliers <- boxplot.stats(data$price)$out
outliers_idx <- which(data$price %in% outliers)
data[outliers_idx,]

boxplot(data$price, 
        main = "Wartości odstające dla zmiennej 'price'",
        ylab = "Wartości price",
        col = "lightblue",
        outline = TRUE)

data[outliers_idx, 2] <- data[outliers_idx, 2] / 10

data_with_outliars <- read.csv("agencja_nieruchomosci.csv")
```

### Analiza wartości odstających dla zmiennej 'area'

Drugą zmienną w której mogą wystapić wartości odstające jest zmienna 'area'. Dlatego przechodzimy do identyfikacji wartości odstających w zmiennej `area` do ich lepszego zobrazowania wykorzystamy wykres pudełkowy. Widzimy, że są to wartości ekstremalnie wysokie. Na razie nie będziemy modyfikować tych wartości. Z perspektywy biznesowej ważne jest aby zbadać jak duża powierzchnia wpływa na cenę. Czy w przypadku odstających pod katem wielkości są one również zdecydowanie droższe.

```{r}

outliers <- boxplot.stats(data$area)$out
outliers_idx <- which(data$area %in% outliers)
data[outliers_idx,]

boxplot(data$area, 
        main = "Wartości odstające dla zmiennej 'area'",
        ylab = "Wartości area",
        col = "lightblue",
        outline = TRUE)

```

# Eksploracja danych

## Sortowanie danych rosnąco według zmiennej 'price'.

Ponieważ Dla naszej analizy kluczową zmienną będzie cena a pytania jake sobie postawimy będą głównie związane z tym jakie czynniki na nią wpływają. ustawienie danych roznąco pod kątem ceny ułatwi prace i podglądanie struktury danych. Łatwiej w ten sposób zauważyć jakie są

```{r}
data %>% arrange('price')
```

## Analiza struktury danych pod kątem zmiennych

```{r}

logical_columns <- c("mainroad", "guestroom", "basement", "hotwaterheating", "airconditioning", "prefarea")

for (col in logical_columns) {
  total <- sum(!is.na(data[[col]]))
  true_percent <- round(sum(data[[col]] == TRUE, na.rm = TRUE) / total * 100, 2)
  false_percent <- round(sum(data[[col]] == FALSE, na.rm = TRUE) / total * 100, 2)
  cat(sprintf("Kolumna: %s, TRUE: %.2f%%, FALSE: %.2f%%\n", col, true_percent, false_percent))
}
```

Kolumna: mainroad, TRUE: 86.46%, FALSE: 13.54%
Kolumna: guestroom, TRUE: 17.80%, FALSE: 82.20%
Kolumna: basement, TRUE: 35.05%, FALSE: 64.95%
Kolumna: hotwaterheating, TRUE: 4.59%, FALSE: 95.41%
Kolumna: airconditioning, TRUE: 31.56%, FALSE: 68.44%
Kolumna: prefarea, TRUE: 24.65%, FALSE: 75.35%

Dodatkowo aby lepiej zobarzować dane pokazane w podsumowaniu tworzymy wykresy słupkowe dla podanych zmiennych

```{r}
for (col in logical_columns) {
  true_percent <- mean(data[[col]] == TRUE, na.rm = TRUE) * 100
  false_percent <- mean(data[[col]] == FALSE, na.rm = TRUE) * 100
  
  barplot(
    c("TRUE" = true_percent, "FALSE" = false_percent),
    main = paste("Procent TRUE/FALSE dla", col),
    ylab = "Procent",
    col = c("lightblue", "lightcoral")
  )
}
```

### Analiza struktury danych dla zmiennej 'furnishingstatus'

```{r}
furnishing_counts <- table(data$furnishingstatus)
furnishing_percentages <- round(prop.table(furnishing_counts) * 100, 2)


print(furnishing_percentages)


barplot(
  furnishing_percentages,
  main = "Procentowy rozkład furnishingstatus",
  ylab = "Procent",
  col = c("lightblue", "lightgreen", "lightcoral"),
  names.arg = names(furnishing_percentages)
)
```

## Imputacja braków danych metodą sequential hotdeck

Zdecydowałyśmy się na metodę sequential hot-deck do imputacji brakujących danych.Metoda Sequential hot-deck wykorzystuje rzeczywiste wartości z naszego zbioru danych, co sprawia, że prawdopodobieństwo wprowadzenia sztucznych wartości jest małe. Dodatkowo załeży nam na zachowaniu naturalnego rozkładu danych. Metoda ta jest elastyczna i działa zarówno dla danych liczbowych, jak i kategorycznych, nie wymagając założeń o rozkładzie zmiennych. Dodatkowo, metoda ta jest odporna na outliery co było dla nas ważne po wcześniejszym zbadaniu ich występowania dla zmiennych price i area. na koniec prównamy brakujące dane przed i po imputacji aby upewnić się, że proces przebiegł pomyślnie.

```{r}

data_not_cleaned <- hotdeck(data)


cat("Liczba brakujących wartości po imputacji:", sum(is.na(data_not_cleaned)), "\n")


remove_imp_columns <- function(df) {
 
  if (!is.data.frame(df)) {
    stop("Podany obiekt nie jest ramką danych")
  }
  
 
  imp_cols <- grep("_imp$", colnames(df), value = TRUE)
  
 
  if (length(imp_cols) == 0) {
    message("Nie znaleziono kolumn z '_imp' w nazwie.")
    return(df)
  }
  

  df_cleaned <- df[, !colnames(df) %in% imp_cols]
  
  message("Usunięto następujące kolumny: ", paste(imp_cols, collapse = ", "))
  
  return(df_cleaned)
}


data_imputed <- remove_imp_columns(data_not_cleaned)


cat("Struktura danych po usunięciu kolumn '_imp':")
str(data_imputed)


head(data_imputed)
```
#Normalizacja zmiennych numerycznych 

Kolejnym etapem jest normalizacja zmiennych numerycznych, takich jak cena, powierzchnia, liczba sypialni, czy liczba miejsc parkingowych, co pozwala na przekształcenie danych do wspólnej skali bez utraty relatywnej informacji. Do tego celu wykorzystano metodę min-max scaling, która przekształca wartości w przedziale od 0 do 1, co ułatwia dalsze analizy statystyczne oraz modelowanie. Proces normalizacji zapewnia większą spójność danych i eliminuje wpływ różnych skal poszczególnych zmiennych na wyniki analizy.Dzięki zastosowanym technikom przetwarzania danych uzyskane wyniki pozwolą na dokładniejszą interpretację wpływu poszczególnych cech nieruchomości na ich wartość rynkową oraz na lepsze przygotowanie danych do wykorzystania w modelach predykcyjnych.

```{r}
minmax <- function(data, columns_to_normalize) {
  # Sprawdzenie, czy podane kolumny istnieją w danych
  missing_cols <- setdiff(columns_to_normalize, colnames(data))
  if (length(missing_cols) > 0) {
    stop(paste("Nie znaleziono kolumn:", paste(missing_cols, collapse = ", ")))
  }
  
  # Normalizacja wybranych kolumn
  data_imputed <- data %>%
    mutate(across(all_of(columns_to_normalize), 
                  ~ ifelse(all(is.na(.)), NA,  # Jeśli wszystkie wartości NA, zwróć NA
                           ifelse((max(., na.rm = TRUE) - min(., na.rm = TRUE)) == 0, 
                                  0,  # Jeśli brak rozstępu, przypisz 0
                                  (.-min(., na.rm = TRUE)) / (max(., na.rm = TRUE) - min(., na.rm = TRUE)))),
                  .names = "norm_{.col}"))
  
  return(data_imputed)
}

```
Wizualizacja danych
1. Mapowanie danych (wykresy)
Na przykładzie zależności między ceną (price) a powierzchnią (area).
```{r}
# Wykres rozrzutu z ceną na osi Y i powierzchnią na osi X
library(ggplot2)

ggplot(data_imputed, aes(x = area, y = price, color = prefarea)) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_manual(values = c("yes" = "blue", "no" = "red")) +
  labs(title = "Cena vs. Powierzchnia z podziałem na preferowaną lokalizację",
       x = "Powierzchnia (m2)",
       y = "Cena (PLN)") +
  theme_minimal()

```
2. Wizualizacja ilości
a) Histogram rozkładu liczby sypialni (bedrooms).
```{r}
# Histogram liczby sypialni
ggplot(data_imputed, aes(x = bedrooms)) +
  geom_bar(fill = "steelblue", color = "black", alpha = 0.8) +
  labs(title = "Rozkład liczby sypialni",
       x = "Liczba sypialni",
       y = "Liczba nieruchomości") +
  theme_minimal()

```
b) Liczba nieruchomości w zależności od dostępu do drogi głównej (mainroad):
```{r}
# Histogram liczby nieruchomości z dostępem do drogi głównej
ggplot(data_imputed, aes(x = mainroad)) +
  geom_bar(fill = "orange", color = "black", alpha = 0.8) +
  labs(title = "Liczba nieruchomości z dostępem do drogi głównej",
       x = "Dostęp do drogi głównej",
       y = "Liczba nieruchomości") +
  theme_minimal()

```
c) Liczba nieruchomości z klimatyzacją (airconditioning):
```{r}
# Histogram liczby nieruchomości z klimatyzacją
ggplot(data_imputed, aes(x = airconditioning)) +
  geom_bar(fill = "cyan", color = "black", alpha = 0.8) +
  labs(title = "Liczba nieruchomości z klimatyzacją",
       x = "Klimatyzacja",
       y = "Liczba nieruchomości") +
  theme_minimal()

```
3. Wizualizacja rozkładów
a) Wykres rozkładu powierzchni (area) z podziałem na obecność klimatyzacji (airconditioning).
```{r}
# Wykres gęstości powierzchni z podziałem na klimatyzację
ggplot(data_imputed, aes(x = area, fill = airconditioning)) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("yes" = "green", "no" = "orange")) +
  labs(title = "Rozkład powierzchni w zależności od klimatyzacji",
       x = "Powierzchnia (m2)",
       y = "Gęstość",
       fill = "Klimatyzacja") +
  theme_minimal()

```
b) Rozkład cen (price) z podziałem na status umeblowania (furnishingstatus):
```{r}
# Rozkład cen z podziałem na umeblowanie
ggplot(data_imputed, aes(x = price, fill = furnishingstatus)) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("furnished" = "purple", "semi-furnished" = "pink", "unfurnished" = "grey")) +
  labs(title = "Rozkład cen w zależności od statusu umeblowania",
       x = "Cena (PLN)",
       y = "Gęstość",
       fill = "Status umeblowania") +
  theme_minimal()

```
c) Rozkład liczby parkingów (parking):
```{r}
# Rozkład liczby parkingów
ggplot(data_imputed, aes(x = parking)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black", alpha = 0.8) +
  labs(title = "Rozkład liczby parkingów",
       x = "Liczba parkingów",
       y = "Liczba nieruchomości") +
  theme_minimal()

```
4. Wizualizacja proporcji
a) Wykres kołowy dla statusu umeblowania (furnishingstatus).
```{r}
# Proporcje statusu umeblowania
library(dplyr)

data_imputed %>%
  count(furnishingstatus) %>%
  ggplot(aes(x = "", y = n, fill = furnishingstatus)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  scale_fill_manual(values = c("furnished" = "purple", "semi-furnished" = "pink", "unfurnished" = "grey")) +
  labs(title = "Proporcja statusu umeblowania",
       fill = "Status umeblowania") +
  theme_void()

```
b) Proporcje dostępu do piwnicy (basement):
```{r}
data_imputed %>%
  count(basement) %>%
  ggplot(aes(x = "", y = n, fill = basement)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  scale_fill_manual(values = c("TRUE" = "blue", "FALSE" = "gray")) +
  labs(title = "Proporcja nieruchomości z piwnicą",
       fill = "Piwnica") +
  theme_void()


```
c) Proporcja nieruchomości z ogrzewaniem wody (hotwaterheating):
```{r}
# Wykres proporcji ogrzewania wody
data_imputed %>%
  count(hotwaterheating) %>%
  ggplot(aes(x = "", y = n, fill = hotwaterheating)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  scale_fill_manual(values = c("TRUE" = "green", "FALSE" = "red")) +
  labs(title = "Proporcja nieruchomości z ogrzewaniem wody",
       fill = "Ogrzewanie wody") +
  theme_void()

```



