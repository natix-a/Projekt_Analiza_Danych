---
title: "Untitled"
output: html_document
date: "2024-12-08"
---

---
title: "Projekt Analiza Danych"
date: "`r Sys.Date()`"
output:
  rmdformats::downcute:
    self_contained: true
    default_style: "light"
    downcute_theme: "default"
---

 # Projekt_Analiza_Danych
 
GitGirls 

W składzie: 
1. Natalia Adamczyk 
2. Paulina Lackowska
3. Wiktoria Gliniecka


Baza danych: Agencja nieruchomości - raport na temat agencji nieruchomości, dowiedzieć się od czego zależy CENA nieruchomości, czyli domy, mieszkania. 

Plik: agencja_nieruchomosci

```{r setup, include=FALSE}
## Global optionsuuuuuu
knitr::opts_chunk$set(cache = TRUE)
```


```{r}
library(dplyr)
library(naniar)
library(ggplot2)
library(VIM)
library(editrules)
library(validate)
library(editrules)
```


```{r}
#Read data from .csv
data <- read.csv("agencja_nieruchomosci.csv")
```

Podgląd danych

```{r}
#Data preview
head(data)
```

Struktura danych

```{r}
str(data)
```

Eksploracja brakujących danych

Całkowita liczbę NA dla całej ramki danych lub dla określonej zmiennej (kolumny)

```{r}
n_miss(data)
```

Całkowita liczbę NA dla zmiennych (kolumn)

```{r}
n_miss(data$price)
n_miss(data$area)
n_miss(data$bedrooms)
n_miss(data$bathrooms)
n_miss(data$stories)
n_miss(data$mainroad)
n_miss(data$guestroom)
n_miss(data$basement)
n_miss(data$hotwaterheating)
n_miss(data$airconditioning)
n_miss(data$parking)
n_miss(data$prefarea)
n_miss(data$furnishingstatus)
```


liczba wartości innych niż NA w ramce danych lub zmiennej

```{r}
n_complete(data)
```

Proporcja wartości będących NA dla całej ramki danych

```{r}
prop_miss(data)
```

Proporcja wartości będących NA dla poszczególnych kolumn

```{r}
prop_miss(data$price)
prop_miss(data$area)
prop_miss(data$bedrooms)
prop_miss(data$bathrooms)
prop_miss(data$stories)
prop_miss(data$mainroad)
prop_miss(data$guestroom)
prop_miss(data$basement)
prop_miss(data$hotwaterheating)
prop_miss(data$airconditioning)
prop_miss(data$parking)
prop_miss(data$prefarea)
prop_miss(data$furnishingstatus)
```


tabelę podsumowującą zawierającą liczbę brakujących NA

```{r}
miss_var_summary(data) 
```

Wizualizacja brakujących wartości

```{r}
vis_miss(data)
```

Zmiana struktury danych z (yes/no) na dane (true/false)

```{r}
data$mainroad <- ifelse(data$mainroad == "yes", TRUE, 
                                ifelse(data$mainroad == "no", FALSE, NA))
                                
data$guestroom <- ifelse(data$guestroom == "yes", TRUE, 
                                ifelse(data$guestroom == "no", FALSE, NA))

data$basement <- ifelse(data$basement == "yes", TRUE, 
                                ifelse(data$basement == "no", FALSE, NA))

data$hotwaterheating <- ifelse(data$hotwaterheating == "yes", TRUE, 
                                ifelse(data$hotwaterheating == "no", FALSE, NA))

data$airconditioning <- ifelse(data$airconditioning == "yes", TRUE, 
                                ifelse(data$airconditioning == "no", FALSE, NA))
                                
data$prefarea <- ifelse(data$prefarea == "yes", TRUE, 
                                ifelse(data$prefarea == "no", FALSE, NA))

```

Definiowanie reguł w celu zwiększenia spójności danych

```{r}
RULE <- editset(c("price > 0","area > 0", "bedrooms >= 1","bathrooms >= 1", "stories >= 1", "mainroad %in% c('TRUE','FALSE')","guestroom %in% c('TRUE','FALSE')", "basement %in% c('TRUE','FALSE')", "hotwaterheating %in% c('TRUE','FALSE')", "airconditioning %in% c('TRUE','FALSE')", "prefarea %in% c('TRUE','FALSE')", "parking >= 0", "furnishingstatus %in% c('furnished','semi-furnished','unfurnished')"))
RULE
```

Podsumowanie wystepowania rekordów niespełniających ustalonej wyżej reguły 

```{r}
summary(violatedEdits(RULE, data))
violations_summary <- summary(violatedEdits(RULE, data))
str(violations_summary)


plot(violated)

```

Z podsumowania danych łamiących zapisaną wyżej regułę wynika, że większość wierszy (66.6%) w danych spełnia wszystkie reguły walidacyjne (errors = 0).
28.4% wierszy narusza jedną regułę (errors = 1). 4.8% wierszy narusza dwie reguły (errors = 2). 0.2% wierszy narusza trzy reguły (errors = 3).To jaka część obserwacji nie spełani reguł możemy zobaczyć na wykresie. 


Dla spójności i poprawności danych stodujemy reguły walidacyjne. Wykorzystujemy zdefiniowane wcześniej reguły. Błędne wartości w danych zastąpujemy NA, co umożliwia ich łatwą identyfikację i w puźniejszych krokach ułatwi wykosztanie ich w analizie. Wykorzystujemy do tego celu bibliotekę validate, aby wszytskie obserwacje łamiące wspomniane regułu zastępujemy wartością NA.Oznacza to, że będzie możliwe implementacja w to miejsce wartości spełniające wymogi danych. 

```{r}
RULE <- validator(
  price > 0,
  area > 0,
  bedrooms >= 1,
  bathrooms >= 1,
  stories >= 1,
  mainroad %in% c('TRUE', 'FALSE'),
  guestroom %in% c('TRUE', 'FALSE'),
  basement %in% c('TRUE', 'FALSE'),
  hotwaterheating %in% c('TRUE', 'FALSE'),
  airconditioning %in% c('TRUE', 'FALSE'),
  prefarea %in% c('TRUE', 'FALSE'),
  parking >= 0,
  furnishingstatus %in% c('furnished', 'semi-furnished', 'unfurnished')
)

correct_with_rules <- function(data, rules) {
  violations <- confront(data, rules)
  for (col in names(data)) {
    if (col %in% names(rules)) {
      invalid_rows <- values(violations)[, col] == FALSE
      data[[col]][invalid_rows] <- NA
    }
  }
  return(data)
}
```

Analiza wartości odstających dla zmiennej 'price' 

Identyfikujemy wartości odstające w zmiennej `price` Następnie znajdujemy indeksy wierszy zawierających te wartości odstające za pomocą funkcji `which`. Używamy wykresu pudełkowegp do wizualizacji zmiennej `price`, gdzie outliery są automatycznie zaznaczane na wykresie. W kolejnych krokach modyfikujemy wartości w drugiej kolumnie dla wierszy z wartościami odstającymi w `price`, dzieląc je przez 10 w celu ich zmniejszenia. Ten proces pozwala nam spojrzeć na przeciętne wartości dla danych o sprzedaży mieszkań. Jeśli chodzi o cenę jest ona zmienną mocno subiektywną. Niekoniecznie wynika z faktycznej wartości produktu ale np. z bardzo konkretnej lokalizacji. Ponieważ w naszych danych nie mamy informacji o np. wspomnianej konkretnej lokalizacji nie możemy wziąć jej pod uwagę przy dalaszej interpretacji ceny. Dane bez wprowqadzonych modyfikacji zostawiamy jako 'data_with_outliars'dla celów porównawczych. 


```{r}
outliers <- boxplot.stats(data$price)$out
outliers_idx <- which(data$price %in% outliers)
data[outliers_idx,]

boxplot(data$price, 
        main = "Wartości odstające dla zmiennej 'price'",
        ylab = "Wartości price",
        col = "lightblue",
        outline = TRUE)

data[outliers_idx, 2] <- data[outliers_idx, 2] / 10

data_with_outliars <- read.csv("agencja_nieruchomosci.csv")
```

Analiza wartości odstających dla zmiennej 'area'

Drugą zmienną w której mogą wystapić wartości odstające jest zmienna 'area'. Dlatego przechodzimy do identyfikacji wartości odstających w zmiennej `area` do ich lepszego zobrazowania wykorzystamy wykres pudełkowy. Widzimy, że są to wartości ekstremalnie wysokie. Na razie nie będziemy modyfikować tych wartości. Z perspektywy biznesowej ważne jest aby zbadać jak duża powierzchnia wpływa na cenę. Czy w przypadku odstających pod katem wielkości są one również zdecydowanie droższe. 

```{r}

outliers <- boxplot.stats(data$area)$out
outliers_idx <- which(data$area %in% outliers)
data[outliers_idx,]

boxplot(data$area, 
        main = "Wartości odstające dla zmiennej 'area'",
        ylab = "Wartości area",
        col = "lightblue",
        outline = TRUE)

```

Imputacja braków danych metodą sequential hotdeck

Zdecydowałyśmy się na metodę sequential hot-deck do imputacji brakujących danych.Metoda Sequential hot-deck wykorzystuje rzeczywiste wartości z naszego zbioru danych, co sprawia, że prawdopodobieństwo wprowadzenia sztucznych wartości jest małe. Dodatkowo załeży nam na zachowaniu naturalnego rozkładu danych. Metoda ta jest elastyczna i działa zarówno dla danych liczbowych, jak i kategorycznych, nie wymagając założeń o rozkładzie zmiennych. Dodatkowo, metoda ta jest odporna na outliery co było dla nas ważne po wcześniejszym zbadaniu ich występowania dla zmiennych price i area. 

```{r}
seqImpute <- function(x, last = max(x, na.rm = TRUE)) {
  n <- length(x)
  x <- c(x, last)
  i <- is.na(x)
  while (any(i)) {
    x[i] <- x[which(i) + 1]
    i <- is.na(x)
  }
  x[1:n]
}


for (col in names(agencja_nieruchomosci)) {
  if (is.numeric(agencja_nieruchomosci[[col]])) {
    
    o <- order(agencja_nieruchomosci[[col]], na.last = TRUE)
    imputowane <- seqImpute(agencja_nieruchomosci[[col]][o])
    agencja_nieruchomosci[[col]][o] <- imputowane
  }
}


summary(agencja_nieruchomosci)

```

Eksploracja danych 

Sortowanie danych według zmiennej 'price' 

Grupowanie według kategorii i analiza struktury danych pąd kątem tych grup 

Analiza struktury danych dla zmiennej 'furnishingstatus'


Wizualizacja danych
```{r}
gg_miss_upset(data, 
              nsets = 3)
              
ggplot(data = data, aes(x = price, y = furnishingstatus)) +
  geom_point(size = 2, color = "cyan4") +
  theme_minimal()
```

Załaduj ggplot2
Tworzenie wykresu punktowego

```{r} 



ggplot(data = data, aes(x = area, y = price)) +
  geom_point() +
  labs(
    title = "Cena nieruchomości wg powierzchni",
    x = "Powierzchnia",
    y = "Cena"
  ) +
  theme_minimal()

library(ggplot2)
```
```
Wykres punktowy ceny w zależności od powierzchni

```{r}
ggplot(data = data, aes(x = area, y = price)) +
  geom_point(aes(color = price), size = 3, alpha = 0.7) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(
    title = "Cena nieruchomości w zależności od powierzchni",
    x = "Powierzchnia (m²)",
    y = "Cena (zł)",
    color = "Cena"
  ) +
  theme_minimal()
```

Wykres słupkowy pięter w zależności od umeblowania

```{r}
ggplot(data = data, aes(x = factor(stories), fill = furnishingstatus)) +
  geom_bar(position = "dodge") +
  labs(
    title = "Liczba pięter w zależności od statusu umeblowania",
    x = "Liczba pięter",
    y = "Liczba nieruchomości",
    fill = "Status umeblowania"
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")
```

Wykres boxplot ceny względem klimatyzacji

```{r}
ggplot(data = data, aes(x = factor(airconditioning), y = price, fill = factor(airconditioning))) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("skyblue", "orange")) +
  labs(
    title = "Cena nieruchomości w zależności od klimatyzacji",
    x = "Klimatyzacja (0 = brak, 1 = obecna)",
    y = "Cena (zł)",
    fill = "Klimatyzacja"
  ) +
  theme_minimal()
```

Histogram cen z uwzględnieniem głównej drogi

```{r}
ggplot(data = data, aes(x = price, fill = factor(mainroad))) +
  geom_histogram(position = "dodge", bins = 30, alpha = 0.7) +
  scale_fill_manual(values = c("darkgreen", "yellow")) +
  labs(
    title = "Rozkład cen nieruchomości w zależności od obecności przy głównej drodze",
    x = "Cena (zł)",
    y = "Liczba nieruchomości",
    fill = "Główna droga (0 = brak, 1 = obecność)"
  ) +
  theme_minimal()
```

Zmiana zmiennych na kategorie, jeśli nie są już ustawione

```{r}
data <- data %>%
  mutate(
    mainroad = as.factor(mainroad),
    prefarea = as.factor(prefarea),
    airconditioning = as.factor(airconditioning),
    guestroom = as.factor(guestroom),
    basement = as.factor(basement),
    hotwaterheating = as.factor(hotwaterheating),
    furnishingstatus = as.factor(furnishingstatus)
  )
```

```{r}
ggplot(data = data, aes(x = mainroad, y = price, fill = mainroad)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("darkgreen", "yellow")) +
  labs(
    title = "Cena nieruchomości w zależności od obecności głównej drogi",
    x = "Główna droga (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Główna droga"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = prefarea, y = price, fill = prefarea)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("skyblue", "orange")) +
  labs(
    title = "Cena nieruchomości w zależności od preferowanej lokalizacji",
    x = "Preferowana lokalizacja (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Preferowana lokalizacja"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = airconditioning, y = price, fill = airconditioning)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("blue", "red")) +
  labs(
    title = "Cena nieruchomości w zależności od klimatyzacji",
    x = "Klimatyzacja (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Klimatyzacja"
  ) +
  theme_minimal()
```

```{r}
  ggplot(data = data, aes(x = guestroom, y = price, fill = guestroom)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("purple", "green")) +
  labs(
    title = "Cena nieruchomości w zależności od pokoju gościnnego",
    x = "Pokój gościnny (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Pokój gościnny"
  ) +
  theme_minimal()
```

```{r}
  ggplot(data = data, aes(x = basement, y = price, fill = basement)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("grey", "brown")) +
  labs(
    title = "Cena nieruchomości w zależności od piwnicy",
    x = "Piwnica (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Piwnica"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = hotwaterheating, y = price, fill = hotwaterheating)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("cyan", "pink")) +
  labs(
    title = "Cena nieruchomości w zależności od ogrzewania ciepłą wodą",
    x = "Ogrzewanie ciepłą wodą (0 = brak, 1 = obecność)",
    y = "Cena (zł)",
    fill = "Ogrzewanie"
  ) +
  theme_minimal()
```

```{r}
ggplot(data = data, aes(x = furnishingstatus, y = price, fill = furnishingstatus)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Cena nieruchomości w zależności od statusu umeblowania",
    x = "Status umeblowania",
    y = "Cena (zł)",
    fill = "Umeblowanie"
  ) +
  theme_minimal()
```

